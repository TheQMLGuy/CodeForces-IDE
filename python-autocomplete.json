{
  "builtins": {
    "abs": { "signature": "abs(x)", "doc": "Return absolute value of number", "type": "function" },
    "all": { "signature": "all(iterable)", "doc": "Return True if all elements are truthy", "type": "function" },
    "any": { "signature": "any(iterable)", "doc": "Return True if any element is truthy", "type": "function" },
    "bin": { "signature": "bin(x)", "doc": "Convert integer to binary string", "type": "function" },
    "bool": { "signature": "bool(x=False)", "doc": "Convert to boolean", "type": "class" },
    "chr": { "signature": "chr(i)", "doc": "Return Unicode character for integer", "type": "function" },
    "dict": { "signature": "dict(**kwargs)", "doc": "Create dictionary", "type": "class" },
    "divmod": { "signature": "divmod(a, b)", "doc": "Return (quotient, remainder)", "type": "function" },
    "enumerate": { "signature": "enumerate(iterable, start=0)", "doc": "Return enumerate object", "type": "function" },
    "filter": { "signature": "filter(function, iterable)", "doc": "Filter elements by function", "type": "function" },
    "float": { "signature": "float(x=0.0)", "doc": "Convert to float", "type": "class" },
    "format": { "signature": "format(value, format_spec)", "doc": "Format value using spec", "type": "function" },
    "frozenset": { "signature": "frozenset(iterable)", "doc": "Create immutable set", "type": "class" },
    "hex": { "signature": "hex(x)", "doc": "Convert integer to hex string", "type": "function" },
    "input": { "signature": "input(prompt='')", "doc": "Read line from input", "type": "function" },
    "int": { "signature": "int(x=0, base=10)", "doc": "Convert to integer", "type": "class" },
    "isinstance": { "signature": "isinstance(obj, classinfo)", "doc": "Check if object is instance", "type": "function" },
    "iter": { "signature": "iter(object)", "doc": "Return iterator object", "type": "function" },
    "len": { "signature": "len(s)", "doc": "Return length of object", "type": "function" },
    "list": { "signature": "list(iterable)", "doc": "Create list", "type": "class" },
    "map": { "signature": "map(function, iterable, ...)", "doc": "Apply function to all items", "type": "function" },
    "max": { "signature": "max(iterable, key=None)", "doc": "Return maximum value", "type": "function" },
    "min": { "signature": "min(iterable, key=None)", "doc": "Return minimum value", "type": "function" },
    "next": { "signature": "next(iterator, default)", "doc": "Get next item from iterator", "type": "function" },
    "oct": { "signature": "oct(x)", "doc": "Convert integer to octal string", "type": "function" },
    "open": { "signature": "open(file, mode='r')", "doc": "Open file and return file object", "type": "function" },
    "ord": { "signature": "ord(c)", "doc": "Return Unicode code for character", "type": "function" },
    "pow": { "signature": "pow(base, exp, mod=None)", "doc": "Return base to the power exp", "type": "function" },
    "print": { "signature": "print(*values, sep=' ', end='\\n')", "doc": "Print values to stdout", "type": "function" },
    "range": { "signature": "range(stop) or range(start, stop, step)", "doc": "Generate sequence of numbers", "type": "class" },
    "repr": { "signature": "repr(object)", "doc": "Return printable representation", "type": "function" },
    "reversed": { "signature": "reversed(seq)", "doc": "Return reversed iterator", "type": "function" },
    "round": { "signature": "round(number, ndigits=None)", "doc": "Round number to ndigits", "type": "function" },
    "set": { "signature": "set(iterable)", "doc": "Create set object", "type": "class" },
    "slice": { "signature": "slice(start, stop, step)", "doc": "Create slice object", "type": "class" },
    "sorted": { "signature": "sorted(iterable, key=None, reverse=False)", "doc": "Return sorted list", "type": "function" },
    "str": { "signature": "str(object='')", "doc": "Convert to string", "type": "class" },
    "sum": { "signature": "sum(iterable, start=0)", "doc": "Sum of items", "type": "function" },
    "tuple": { "signature": "tuple(iterable)", "doc": "Create tuple", "type": "class" },
    "type": { "signature": "type(object)", "doc": "Return type of object", "type": "function" },
    "zip": { "signature": "zip(*iterables)", "doc": "Zip iterables together", "type": "function" }
  },
  "collections": {
    "Counter": { "signature": "Counter(iterable)", "doc": "Dict for counting hashable objects", "type": "class" },
    "defaultdict": { "signature": "defaultdict(default_factory)", "doc": "Dict with default values", "type": "class" },
    "deque": { "signature": "deque(iterable, maxlen=None)", "doc": "Double-ended queue", "type": "class" },
    "namedtuple": { "signature": "namedtuple(typename, field_names)", "doc": "Create tuple subclass with named fields", "type": "function" },
    "OrderedDict": { "signature": "OrderedDict()", "doc": "Dict that remembers insertion order", "type": "class" }
  },
  "itertools": {
    "accumulate": { "signature": "accumulate(iterable, func=add, initial=None)", "doc": "Accumulated sums/products", "type": "function" },
    "chain": { "signature": "chain(*iterables)", "doc": "Chain iterables together", "type": "function" },
    "combinations": { "signature": "combinations(iterable, r)", "doc": "r-length combinations", "type": "function" },
    "combinations_with_replacement": { "signature": "combinations_with_replacement(iterable, r)", "doc": "r-length combinations with repetition", "type": "function" },
    "count": { "signature": "count(start=0, step=1)", "doc": "Infinite counting iterator", "type": "function" },
    "cycle": { "signature": "cycle(iterable)", "doc": "Infinite cycling iterator", "type": "function" },
    "dropwhile": { "signature": "dropwhile(predicate, iterable)", "doc": "Drop while predicate is true", "type": "function" },
    "filterfalse": { "signature": "filterfalse(predicate, iterable)", "doc": "Filter elements where predicate is false", "type": "function" },
    "groupby": { "signature": "groupby(iterable, key=None)", "doc": "Group consecutive elements", "type": "function" },
    "islice": { "signature": "islice(iterable, stop) or islice(iterable, start, stop, step)", "doc": "Slice an iterator", "type": "function" },
    "permutations": { "signature": "permutations(iterable, r=None)", "doc": "r-length permutations", "type": "function" },
    "product": { "signature": "product(*iterables, repeat=1)", "doc": "Cartesian product", "type": "function" },
    "repeat": { "signature": "repeat(object, times=None)", "doc": "Repeat object", "type": "function" },
    "starmap": { "signature": "starmap(function, iterable)", "doc": "Apply function using argument tuples", "type": "function" },
    "takewhile": { "signature": "takewhile(predicate, iterable)", "doc": "Take while predicate is true", "type": "function" },
    "zip_longest": { "signature": "zip_longest(*iterables, fillvalue=None)", "doc": "Zip to longest iterable", "type": "function" }
  },
  "math": {
    "ceil": { "signature": "ceil(x)", "doc": "Ceiling of x", "type": "function" },
    "comb": { "signature": "comb(n, k)", "doc": "Number of combinations n choose k", "type": "function" },
    "copysign": { "signature": "copysign(x, y)", "doc": "x with sign of y", "type": "function" },
    "factorial": { "signature": "factorial(n)", "doc": "n factorial", "type": "function" },
    "floor": { "signature": "floor(x)", "doc": "Floor of x", "type": "function" },
    "gcd": { "signature": "gcd(*integers)", "doc": "Greatest common divisor", "type": "function" },
    "isqrt": { "signature": "isqrt(n)", "doc": "Integer square root", "type": "function" },
    "lcm": { "signature": "lcm(*integers)", "doc": "Least common multiple", "type": "function" },
    "log": { "signature": "log(x, base=e)", "doc": "Logarithm of x", "type": "function" },
    "log2": { "signature": "log2(x)", "doc": "Base-2 logarithm", "type": "function" },
    "log10": { "signature": "log10(x)", "doc": "Base-10 logarithm", "type": "function" },
    "perm": { "signature": "perm(n, k=None)", "doc": "Number of permutations", "type": "function" },
    "pow": { "signature": "pow(x, y)", "doc": "x raised to power y", "type": "function" },
    "prod": { "signature": "prod(iterable, start=1)", "doc": "Product of elements", "type": "function" },
    "sqrt": { "signature": "sqrt(x)", "doc": "Square root of x", "type": "function" },
    "trunc": { "signature": "trunc(x)", "doc": "Truncate to integer", "type": "function" },
    "inf": { "signature": "inf", "doc": "Positive infinity", "type": "constant" },
    "pi": { "signature": "pi", "doc": "Mathematical constant Ï€", "type": "constant" },
    "e": { "signature": "e", "doc": "Mathematical constant e", "type": "constant" }
  },
  "heapq": {
    "heappush": { "signature": "heappush(heap, item)", "doc": "Push item onto heap", "type": "function" },
    "heappop": { "signature": "heappop(heap)", "doc": "Pop smallest item from heap", "type": "function" },
    "heapify": { "signature": "heapify(x)", "doc": "Transform list into heap in-place", "type": "function" },
    "heapreplace": { "signature": "heapreplace(heap, item)", "doc": "Pop and push in one operation", "type": "function" },
    "heappushpop": { "signature": "heappushpop(heap, item)", "doc": "Push then pop in one operation", "type": "function" },
    "nlargest": { "signature": "nlargest(n, iterable, key=None)", "doc": "Find n largest elements", "type": "function" },
    "nsmallest": { "signature": "nsmallest(n, iterable, key=None)", "doc": "Find n smallest elements", "type": "function" }
  },
  "bisect": {
    "bisect_left": { "signature": "bisect_left(a, x, lo=0, hi=len(a))", "doc": "Locate leftmost insertion point", "type": "function" },
    "bisect_right": { "signature": "bisect_right(a, x, lo=0, hi=len(a))", "doc": "Locate rightmost insertion point", "type": "function" },
    "bisect": { "signature": "bisect(a, x)", "doc": "Alias for bisect_right", "type": "function" },
    "insort_left": { "signature": "insort_left(a, x)", "doc": "Insert x in sorted list (leftmost)", "type": "function" },
    "insort_right": { "signature": "insort_right(a, x)", "doc": "Insert x in sorted list (rightmost)", "type": "function" },
    "insort": { "signature": "insort(a, x)", "doc": "Alias for insort_right", "type": "function" }
  },
  "functools": {
    "cache": { "signature": "@cache", "doc": "Simple unbounded cache decorator", "type": "decorator" },
    "lru_cache": { "signature": "@lru_cache(maxsize=128)", "doc": "LRU cache decorator", "type": "decorator" },
    "reduce": { "signature": "reduce(function, iterable, initializer=None)", "doc": "Apply function cumulatively", "type": "function" },
    "partial": { "signature": "partial(func, *args, **kwargs)", "doc": "Partial function application", "type": "function" },
    "cmp_to_key": { "signature": "cmp_to_key(func)", "doc": "Convert comparison function to key", "type": "function" }
  },
  "sys": {
    "stdin": { "signature": "sys.stdin", "doc": "Standard input stream", "type": "object" },
    "stdout": { "signature": "sys.stdout", "doc": "Standard output stream", "type": "object" },
    "maxsize": { "signature": "sys.maxsize", "doc": "Maximum integer value", "type": "constant" },
    "setrecursionlimit": { "signature": "setrecursionlimit(limit)", "doc": "Set max recursion depth", "type": "function" },
    "exit": { "signature": "exit(status=0)", "doc": "Exit the program", "type": "function" }
  },
  "string": {
    "ascii_lowercase": { "signature": "string.ascii_lowercase", "doc": "'abcdefghijklmnopqrstuvwxyz'", "type": "constant" },
    "ascii_uppercase": { "signature": "string.ascii_uppercase", "doc": "'ABCDEFGHIJKLMNOPQRSTUVWXYZ'", "type": "constant" },
    "ascii_letters": { "signature": "string.ascii_letters", "doc": "All ASCII letters", "type": "constant" },
    "digits": { "signature": "string.digits", "doc": "'0123456789'", "type": "constant" }
  },
  "re": {
    "match": { "signature": "re.match(pattern, string)", "doc": "Match pattern at start of string", "type": "function" },
    "search": { "signature": "re.search(pattern, string)", "doc": "Search for pattern in string", "type": "function" },
    "findall": { "signature": "re.findall(pattern, string)", "doc": "Find all matches", "type": "function" },
    "sub": { "signature": "re.sub(pattern, repl, string)", "doc": "Replace pattern matches", "type": "function" },
    "split": { "signature": "re.split(pattern, string)", "doc": "Split by pattern", "type": "function" },
    "compile": { "signature": "re.compile(pattern)", "doc": "Compile regex pattern", "type": "function" }
  },
  "list_methods": {
    "append": { "signature": "list.append(x)", "doc": "Add item to end", "type": "method" },
    "extend": { "signature": "list.extend(iterable)", "doc": "Extend list by iterable", "type": "method" },
    "insert": { "signature": "list.insert(i, x)", "doc": "Insert item at index", "type": "method" },
    "remove": { "signature": "list.remove(x)", "doc": "Remove first occurrence", "type": "method" },
    "pop": { "signature": "list.pop(i=-1)", "doc": "Remove and return item", "type": "method" },
    "clear": { "signature": "list.clear()", "doc": "Remove all items", "type": "method" },
    "index": { "signature": "list.index(x)", "doc": "Return index of x", "type": "method" },
    "count": { "signature": "list.count(x)", "doc": "Count occurrences of x", "type": "method" },
    "sort": { "signature": "list.sort(key=None, reverse=False)", "doc": "Sort list in place", "type": "method" },
    "reverse": { "signature": "list.reverse()", "doc": "Reverse list in place", "type": "method" },
    "copy": { "signature": "list.copy()", "doc": "Return shallow copy", "type": "method" }
  },
  "str_methods": {
    "split": { "signature": "str.split(sep=None, maxsplit=-1)", "doc": "Split string by separator", "type": "method" },
    "join": { "signature": "str.join(iterable)", "doc": "Join iterable with string", "type": "method" },
    "strip": { "signature": "str.strip(chars=None)", "doc": "Remove leading/trailing chars", "type": "method" },
    "lstrip": { "signature": "str.lstrip(chars=None)", "doc": "Remove leading chars", "type": "method" },
    "rstrip": { "signature": "str.rstrip(chars=None)", "doc": "Remove trailing chars", "type": "method" },
    "replace": { "signature": "str.replace(old, new, count=-1)", "doc": "Replace occurrences", "type": "method" },
    "find": { "signature": "str.find(sub, start=0, end=len)", "doc": "Find substring index", "type": "method" },
    "rfind": { "signature": "str.rfind(sub)", "doc": "Find substring from right", "type": "method" },
    "startswith": { "signature": "str.startswith(prefix)", "doc": "Check if starts with prefix", "type": "method" },
    "endswith": { "signature": "str.endswith(suffix)", "doc": "Check if ends with suffix", "type": "method" },
    "upper": { "signature": "str.upper()", "doc": "Return uppercase copy", "type": "method" },
    "lower": { "signature": "str.lower()", "doc": "Return lowercase copy", "type": "method" },
    "capitalize": { "signature": "str.capitalize()", "doc": "Capitalize first character", "type": "method" },
    "title": { "signature": "str.title()", "doc": "Titlecase string", "type": "method" },
    "isdigit": { "signature": "str.isdigit()", "doc": "Check if all digits", "type": "method" },
    "isalpha": { "signature": "str.isalpha()", "doc": "Check if all alphabetic", "type": "method" },
    "isalnum": { "signature": "str.isalnum()", "doc": "Check if alphanumeric", "type": "method" },
    "count": { "signature": "str.count(sub)", "doc": "Count substring occurrences", "type": "method" },
    "format": { "signature": "str.format(*args, **kwargs)", "doc": "Format string", "type": "method" },
    "zfill": { "signature": "str.zfill(width)", "doc": "Pad with zeros on left", "type": "method" }
  },
  "dict_methods": {
    "get": { "signature": "dict.get(key, default=None)", "doc": "Get value or default", "type": "method" },
    "keys": { "signature": "dict.keys()", "doc": "Return view of keys", "type": "method" },
    "values": { "signature": "dict.values()", "doc": "Return view of values", "type": "method" },
    "items": { "signature": "dict.items()", "doc": "Return view of (key, value) pairs", "type": "method" },
    "pop": { "signature": "dict.pop(key, default)", "doc": "Remove and return value", "type": "method" },
    "update": { "signature": "dict.update(other)", "doc": "Update dict from other", "type": "method" },
    "setdefault": { "signature": "dict.setdefault(key, default=None)", "doc": "Get or set default", "type": "method" },
    "clear": { "signature": "dict.clear()", "doc": "Remove all items", "type": "method" },
    "copy": { "signature": "dict.copy()", "doc": "Return shallow copy", "type": "method" }
  },
  "set_methods": {
    "add": { "signature": "set.add(elem)", "doc": "Add element to set", "type": "method" },
    "remove": { "signature": "set.remove(elem)", "doc": "Remove element (raises KeyError)", "type": "method" },
    "discard": { "signature": "set.discard(elem)", "doc": "Remove element if present", "type": "method" },
    "pop": { "signature": "set.pop()", "doc": "Remove and return arbitrary element", "type": "method" },
    "clear": { "signature": "set.clear()", "doc": "Remove all elements", "type": "method" },
    "union": { "signature": "set.union(*others)", "doc": "Return union of sets", "type": "method" },
    "intersection": { "signature": "set.intersection(*others)", "doc": "Return intersection", "type": "method" },
    "difference": { "signature": "set.difference(*others)", "doc": "Return difference", "type": "method" },
    "symmetric_difference": { "signature": "set.symmetric_difference(other)", "doc": "Return symmetric difference", "type": "method" },
    "issubset": { "signature": "set.issubset(other)", "doc": "Check if subset", "type": "method" },
    "issuperset": { "signature": "set.issuperset(other)", "doc": "Check if superset", "type": "method" }
  },
  "deque_methods": {
    "append": { "signature": "deque.append(x)", "doc": "Add to right side", "type": "method" },
    "appendleft": { "signature": "deque.appendleft(x)", "doc": "Add to left side", "type": "method" },
    "pop": { "signature": "deque.pop()", "doc": "Remove from right side", "type": "method" },
    "popleft": { "signature": "deque.popleft()", "doc": "Remove from left side", "type": "method" },
    "extend": { "signature": "deque.extend(iterable)", "doc": "Extend right side", "type": "method" },
    "extendleft": { "signature": "deque.extendleft(iterable)", "doc": "Extend left side", "type": "method" },
    "rotate": { "signature": "deque.rotate(n=1)", "doc": "Rotate n steps right", "type": "method" },
    "clear": { "signature": "deque.clear()", "doc": "Remove all elements", "type": "method" }
  }
}
